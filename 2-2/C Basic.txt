
% << 나머지 연산자는 두개 피연산자들이 정수형이여야 사용 가능
#include <iostream>

using namespace std;

int main()
{
  double a = 0.1; 숫자 대보기
  double b = 0.2;

  if ( a + b == 0.3)
     cout a+b 0.3입니다
  
  else
    cout a+b는 0.3이 아닙니다

  밑에 것이 출력됨 

숫자가 이진수로 저장되는데 0.1을 이진수로 정확히 저장이 안됨 살짝 오차

Machine Epsilon

1이라는 수가 있다 치면 1이라 가자 가깝지만 구분이 되는 단위

소수점 연산할때
if (a + b == |(0.3 - epsilon)|) 처럼

(부동소수점) 소수점 정수 등을 이진수로 표현법 검색정수, 실수 자료형 크기 참고(byte)

int num1 = 10.0f; 같이 뒤에 f 붙이는 이유
=> C, C++의 경우 실수값은 모두 double 타입만큼 큰 실수로 인식하기 때문.
     (float 크기의 숫자도 double형 크기의 숫자로 인식)
 이 실수를 float 변수에 넣어주려고 하면 정밀도가 큰 숫자를 작은 float에 넣으므로
숫자가 잘릴 수 있다는 에러 메시지 출력
f를 붙여 숫자가 float 형이라는 것을 확실히 나타내는 역할

정수, 실수 오버플로우
정수 : 
실수 : 실수 언더플로우는 0 또는 쓰레기값
         실수 오버플로우는 inf(무한대)

switch문 쓸때
switch(a)
case 1: // case 옆에는 변수를 쓸수 없음 상수만 or #define된 변수만
case 안에서 변수 선언하려면 {}(중괄호) 써야함

ex)
case 1:
  int num2 = num1; // 컴파일 에러
  printf("%d입니다.\n", num2);
  break;

case 1:
{
  int num2 = num1; //  중괄호를 쓰고 변수 선언 했기 때문에 안뜸
  printf("%d입니다.\n", num2);
  break;
}

& : 비트 AND
| : 비트 OR
^ : 비트 XOR
~ : 비트 NOT
<< : 비트를 왼쪽으로 시프트
>> : 비트를 오른쪽으로 시프트

&=, |=, ^=, ~=, <<=, >>= 가능

2차원 배열 포인터

배열을 함수의 인자로 넘길때
1차원배열은 크기 안써줘도됨
2차원배열 이상은 첫번째 크기는 안써줘도됨 나머지는 쓰고
ex) int numArr[3][4];
     int (*numPtr)[4] = numArr; // 위에 이미 2차원 배열 선언 되어있으면 2중포인터 쓰는거 아님

   괄호가 빠진 int *numPtr[4]는 포인터 4개를 담을 수 있는 배열임
   ex) int *numPtr[4] = {&num1, &num2, &num3, &num4);

2차원 배열 선언 안되어있을때는 2중포인터 사용

int **m = malloc(sizeof(int *) * row);
for(int i = 0; i < row; i++)
{
  m[i] = malloc(sizeof(int) * col);
}
  
3차원 배열이면 arr[높이][세로][가로]

char *s1 = "Hello" 선언하면 읽기전용이라 문자 못바꿈
char s1[] = "Hello" 는 s1[0] = 'a' 처럼 바꿀수 있지만
char s1[];
s1 = "hello"처럼은 안됨 선언하면서 동시에 문자열로 초기화 할것 또는
s1[1]= 'h'; s1[2] = 'e'처럼 따로따로 해야함

char s1[30] = "Beethoven 9th Symphony";에서 s1[9]는 공백임(문자열에서 공백도 포함, '\n'도 포함할 수 있음)
공백을 포함할 수 있지만 scanf로 공백 포함 입력 받으려면
그냥 hello, world를 입력하면 hello, 까지만 저장됨
scanf("%[^\n]s", s1) 처럼 하기

printf("%*s, i+2, ""); << 공백 개수 불규칙하게 나타내려 할때 변수 통해서
%5s와 같이 나타내면 상수로 밖에 안됨

C에서 구조체 정렬할 때 멤버 중 가장 큰 자료형 크기의 배수로 정렬
패딩(padding) : 구조체 정렬 시 남는 공간을 채우는 것

동적 메모리를 할당받은 포인터를
++, -- 연산자로 포인터 연산 하면 포인터에 저장된 메모리 주소 자체가 바뀜
이떄 free함수에서 메모리 주소가 바뀐 포인터로 메모리 해제를 하면
에러 발생
 => 반드시 처음에 메모리를 할당할 때 받은 주소(포인터) 넣어서 free 함수로 해제할 것
ex)  void *ptr = malloc(100); // 동적 메모리 할당
      *(++(int *)ptr) = 10; //증가 연산자 사용했으므로 4만큼 증가한 메모리 주소가 다시 ptr에 저장됨
      free(ptr) // 메모리 주소가 바뀐 포인터로 메모리 해제 하면 에러 발생

int *ten()
{
  int num1 = 10;
   
  return &num1; // 함수에서 지역변수의 주소 반환하는 것은 에러
}

따라서
int *ten()
{
  int *numPtr = malloc(sizeof(int));

  *numPtr = 10;
  
  return numPtr;
}

처럼 동적 메모리 할당 후 포인터 반환하기
 
=> 함수 안에서 & 연산자로 변수의 메모리 주소를 반환하면 안됨
(매개변수와 함수 안에서 선언한 변수는 함수가 끝날 때 모두 사라짐
그러므로 함수 안에서만 쓸 수 있는 변수의 주소를 반환하면 안됨)

함수 반환값 없이 메모리를 전달하려면 이중 포인터 사용

int *p = NULL; 널포인터 초기화 후
주솟값을 출력하면 (printf("%p\n", p)) 하면 00000000
여기서 메모리를 할당하면(malloc(sizeof(int)) 등 
 주소가 똑같이 00000000인게 아니라 다른 주소로 바뀜

for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++) {
			a++;
			if (j == 2)
				break;
		}
	}

break는 전체 반복문에서 빠져나오는 것이 아니라
그 중괄호에 속한 반복문에서만 빠져나옴

만든 함수에서 종료 조건 만들때(ex) 재귀호출 등)
함수 자료형이 void가 아닌 자료형인데 return; 처럼 반환값 안쓰면 쓰레기값 나옴

함수 이름도 포인터다

void hello()
{
~~~
}
void (*fp)();  // 포인터에 괄호 써서 선언

	fp = hello; // 이름만 대입 (hello 뒤에 () 붙이면 함수가 호출되어버림)

반환형, 매개변수 있으면 int (*fp)(int, int); 처럼 선언

반복문 for(int i = 0; i < n; i++)
에서 중간에 break로 바로 탈출하면 i++실행이 안됨